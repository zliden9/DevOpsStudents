# DevOpsStudents
Netology
HelloNetology

5)Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
	Возможно такой один из этих вариантов?
	cat < file > file2
	tee | cat >> file2
	sort file | cat >> file2
	sort < file 1>> file2
Если нет, то видимо я не понимаю задание.


















1)Какого типа команда cd?
	cd команда типа shell bulding(встроенная команда)
Попробуйте объяснить, почему она именно такого типа; 
опишите ход своих мыслей, если считаете что она могла бы быть другого типа.
	Она такого типа потомучто она небходима для удобного использования консоли в рамках оболочки bash
	в связке с другими встроенными программами оболочки.
	Возможно она моглабы быть "Выполняемой командой" с целью её более гибкого изменения и возможности более простой интеграции
	в другие среды и оболочки.
	Возможно она моглабы быть "Alias" с целью её компановки в связку с другими встроенными командами оболочки bash.

2)Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. 
Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.
	grep -c <some_string> <some_file>

3)Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
	это systemd


4)Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
	ls 2> /dev/pts/1

5)Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
	file file1 1> file2


6)Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY?
	Да данные можно вывести.
Сможете ли вы наблюдать выводимые данные?
	Мониторил со второй консоли, да данные отоброжаются.

7)Выполните команду bash 5>&1. К чему она приведет? 
	перестали корректно работать команды bash
Что будет, если вы выполните echo netology > /proc/$$/fd/5?
	bash: /proc/1515/fd/5?: No such file or directory
Почему так происходит?
	потомучто мы пренаправили bash в другой файловый дескриптор
	Можно починить bash 1>&0


8)Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty?
 Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, 
поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.
	Да такое возможно если сделать 
	bash 5>&1
	ls -file1 2>&1 | cat>file2

9)Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?
	введя команду env


10)Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.
	/proc/<PID>/cmdline это файлы только для чтения содержащие полную командную строку для процесса.
	Если файл пустой то это зомби и при обращении будет возвразать 0.
	Аргументы командной строки отображаются в этом файле в виде набора строк, разделенных нулевыми байтами ('\0'), 
	с дополнительным нулевым байтом после последней строки.

	/proc/<PID>/exe файл содержит фактичесский путь к выполняемой команде. При попытке открытия её, откроется исполняемый файл.
	Можно ввести /proc/[pid]/exe, чтобы запустить другую копию того же исполняемого файла, который запускается процессом [pid].
	Если путь был разорван, символическая ссылка будет содержать строку "(удалено)", добавленную к исходному пути. 
	В многопоточном процессе содержимое этой символической ссылки недоступно, если основной поток завершён (обычно вызывая pthread_exit(3))
	Символическая ссылка регулируется режимом доступа ptrace, проверяющим PTRACE_MODE_READ_FSCREDS.
	В Linux 2.0 и более ранних версиях /proc/[pid]/exe является указателем на двоичный файл, который был выполнен, и отображается в виде символической ссылки. Вызов readlink(2) для этого файла в Linux 2.0 возвращает строку
	в формате: [device]:inode.
	Для поиска файлов по параметнам можно испльзовать -inum

11)Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.
	grep sse /proc/cpuinfo : sse, sse2, sse4a


12)При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, 
которая упоминалась в лекции 3.2. Однако:
vagrant@netology1:~$ ssh localhost 'tty'
not a tty
Почитайте, почему так происходит, и как изменить поведение.
	В своей работе протокол SSH опирается на два компонента. На удаленном узле действует сервер SSH, 
	принимающий соединения на порте 22, а в локальной системе действует клиент SSH, осуществляющий обмен информацией с удаленным сервером.
	Так происходит потомучто ssh сервер делает вызов к /dev/ptmx на удаленном сервере,
	а затем ассоциирует с сессией новый /dev/pts/X, иначе любой случайный пользователь может сразу получить доступ в систему,
	поэтому сначала нужно пройти процедуру аутификации.
	Поведение возможно например псправив файл конфига ssh на хосте, или командой chvt присвоением нужного tty, 
	либо при подключении ssh -o "requestTTY=yes" vagrant@vagrant

